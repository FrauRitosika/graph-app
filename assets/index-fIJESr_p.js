var X=Object.defineProperty;var Y=(t,e,n)=>e in t?X(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var d=(t,e,n)=>Y(t,typeof e!="symbol"?e+"":e,n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(i){if(i.ep)return;i.ep=!0;const o=n(i);fetch(i.href,o)}})();var c=(t=>(t[t.x=0]="x",t[t.y=1]="y",t))(c||{});function s(t){return t===0?"x":"y"}function b(t,e){return[t.position[s(e)]-.5*t.size[e?"height":"width"],t.position[s(e)]+.5*t.size[e?"height":"width"]]}function B(t,e){t=t.sort(n=>n);for(let n of e)if(n>t[0]&&n<t[1])return!1;return!0}function W(t,e){return e=e.sort(n=>n),!!(t.every(n=>n<=e[0])||t.every(n=>n>=e[1]))}function h(t,e){const n=t[0].x===t[1].x?c.x:c.y;for(let r of e){const i=[r.cornerPointsWithBorder[0].y,r.cornerPointsWithBorder[1].y],o=[r.cornerPointsWithBorder[0].x,r.cornerPointsWithBorder[3].x];if(!B(n?i:o,[t[0][s(n)]])&&!W([t[0][s(1-n)],t[1][s(1-n)]],1-n?i:o))return!1}return!0}function G(t,e){return!(!y(t.cornerPoints).every(n=>h(n,[e]))||!y(e.cornerPoints).every(n=>h(n,[t])))}function y(t){return t.map((e,n)=>[e,n+1<t.length-1?t[n+1]:t[0]])}class M{constructor(e,n){d(this,"rectStart");d(this,"rectEnd");this.rectStart=e,this.rectEnd=n,this.validateIntersectionRect()}validateIntersectionRect(){if(!G(this.rectStart,this.rectEnd))throw new Error("Ошибка: Прямоугольники расположены слишком близко друг к другу. Между их гранями должно быть минимальное расстояние в 10 пикселей. Пожалуйста, отредактируйте положение прямоугольников.")}}const _=10,u={rectGap:_};class g{constructor(e,n){d(this,"rect");d(this,"cPoint");d(this,"_sideX");d(this,"_sideY");this.rect=e,this.cPoint=n,this._sideX=this.sidePoints(c.x),this._sideY=this.sidePoints(c.y);const r=this.getSide();this.validateConnectionPoint(r),this.validateAngle(r)}getSide(){const e=[this.sideX,this.sideY];for(let n=0;n<2;n++)if(e[n].includes(this.cPoint.point[s(n)]))return n;throw new Error("Ошибка: Точка соединения должна находиться на грани прямоугольника.")}validateConnectionPoint(e){if(B(1-e?this.sideY:this.sideX,[this.cPoint.point[s(1-e)]]))throw new Error("Ошибка: Точка соединения должна находиться на грани прямоугольника.")}sidePoints(e){const n=b(this.rect,e);switch(e){case c.x:this._sideX=n;break;case c.y:this._sideY=n;break;default:throw new Error("Ошибка: Не удалось определить грань прямоугольника")}return n}validateAngle(e){switch(e){case c.x:if(this.cPoint.point[s(e)]===Math.max(...this._sideX)&&this.cPoint.angle===0||this.cPoint.point[s(e)]===Math.min(...this._sideX)&&this.cPoint.angle===180)return;break;case c.y:if(this.cPoint.point[s(e)]===Math.max(...this._sideY)&&this.cPoint.angle===90||this.cPoint.point[s(e)]===Math.min(...this._sideY)&&this.cPoint.angle===270)return;break;default:throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}get cornerPoints(){return[{x:this.sideX[0],y:this.sideY[0]},{x:this.sideX[0],y:this.sideY[1]},{x:this.sideX[1],y:this.sideY[1]},{x:this.sideX[1],y:this.sideY[0]}]}get cornerPointsWithBorder(){const e=[{x:-u.rectGap,y:-u.rectGap},{x:-u.rectGap,y:u.rectGap},{x:u.rectGap,y:u.rectGap},{x:u.rectGap,y:-u.rectGap}];return this.cornerPoints.map((n,r)=>({x:n.x+e[r].x,y:n.y+e[r].y}))}get sideX(){return this._sideX??this.sidePoints(c.x)}get sideY(){return this._sideY??this.sidePoints(c.y)}}function F(t,e,n){for(let r of[{...t,x:e.x},{...t,y:e.y}])if(h([t,r],n)&&h([r,e],n))return{result:!0,point:r};return{result:!1}}function k(t,e){const n=[t.cPoint.point,p(t)],r=p(e);let i=!1;for(let o=0;o<10;o++){const a=F(n[n.length-1],r,[t,e]);if(a.result&&a.point){n.push(a.point),i=!0;break}const P=z(n,r,[t,e]);P&&n.push(P)}if(i)return[...n,r,e.cPoint.point];throw new Error("Произошла ошибка. К сожалению, мы не смогли создать изображение по указанным параметрам. Пожалуйста, проверьте введенные данные и попробуйте снова.")}function p(t){switch(t.cPoint.angle){case 0:return{...t.cPoint.point,x:t.cornerPointsWithBorder[2].x};case 180:return{...t.cPoint.point,x:t.cornerPointsWithBorder[0].x};case 90:return{...t.cPoint.point,y:t.cornerPointsWithBorder[2].y};case 270:return{...t.cPoint.point,y:t.cornerPointsWithBorder[0].y};default:throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}}function z(t,e,n){const r=t[t.length-1].x===t[t.length-2].x?c.x:c.y,i=t[t.length-1];let o;if((i[s(1-r)]-t[t.length-2][s(1-r)])*(e[s(1-r)]-i[s(1-r)])>0&&(o=a(),o.result&&o.point&&h([i,o.point],n))||i[s(r)]<e[s(r)]&&(o=m(i,1-r,n),o.result&&o.point&&h([i,o.point],n))||(o=x(i,1-r,n),o.result&&o.point&&h([i,o.point],n)))return o.point;if(o=a(),o.result&&o.point&&h([i,o.point],n))return o.point;throw new Error("Не удалось получить путь между точками");function a(){return i[s(1-r)]-t[t.length-2][s(1-r)]>0?m(i,r,n):x(i,r,n)}}function m(t,e,n){const r=n.map(i=>[i.cornerPointsWithBorder[0][s(1-e)],i.cornerPointsWithBorder[3][s(1-e)]]).reduce((i,o)=>i.concat(o),[]).filter(i=>i>t[s(1-e)]);return r.length===0?{result:!1}:{result:!0,point:{x:e?Math.min(...r):t.x,y:e?t.y:Math.min(...r)}}}function x(t,e,n){const r=n.map(i=>[i.cornerPointsWithBorder[0][s(1-e)],i.cornerPointsWithBorder[2][s(1-e)]]).reduce((i,o)=>o.concat(i),[]).filter(i=>i<t[s(1-e)]);return r.length===0?{result:!1}:{result:!0,point:{x:e?Math.max(...r):t.x,y:e?t.y:Math.max(...r)}}}function L(t,e,n,r){const i=new M(new g(t,n),new g(e,r));return k(i.rectStart,i.rectEnd)}const N=document.getElementById("errorMessage"),f=document.getElementById("canvas"),l=f.getContext("2d");I();document.getElementById("redrawButton").addEventListener("click",function(t){t.preventDefault(),I()});function $(t,e,n){l&&(l.clearRect(0,0,f.width,f.height),l.fillStyle="rgba(168, 210, 255)",[t,e].forEach(r=>{l.fillRect(r.position.x-.5*r.size.width,r.position.y-.5*r.size.height,r.size.width,r.size.height)}),l.beginPath(),l.moveTo(n[0].x,n[0].y),n.forEach((r,i)=>{i&&l.lineTo(r.x,r.y)}),l.stroke())}function I(){v("");try{const t={rect1:w("rect1"),rect2:w("rect2"),cPoint1:E("rect1"),cPoint2:E("rect2")},e=L(t.rect1,t.rect2,t.cPoint1,t.cPoint2);$(t.rect1,t.rect2,e)}catch(t){let e="Произошла ошибка. К сожалению, мы не смогли создать изображение по указанным параметрам. Пожалуйста, проверьте введенные данные и попробуйте снова.";t instanceof Error&&(e=t.message),v(e);return}}function w(t){return{position:{x:parseFloat(document.getElementById(`${t}X`).value),y:parseFloat(document.getElementById(`${t}Y`).value)},size:{width:parseFloat(document.getElementById(`${t}Width`).value),height:parseFloat(document.getElementById(`${t}Height`).value)}}}function E(t){return{point:{x:parseFloat(document.getElementById(`${t}cPointX`).value),y:parseFloat(document.getElementById(`${t}cPointY`).value)},angle:parseFloat(document.getElementById(`${t}cPointAngle`).value)}}function v(t){N.textContent=t}
