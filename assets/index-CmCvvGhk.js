var j=Object.defineProperty;var q=(t,e,n)=>e in t?j(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var f=(t,e,n)=>q(t,typeof e!="symbol"?e+"":e,n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))o(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const c of r.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&o(c)}).observe(document,{childList:!0,subtree:!0});function n(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function o(i){if(i.ep)return;i.ep=!0;const r=n(i);fetch(i.href,r)}})();function k(t,e){return{x:t.x+e.x,y:t.y+e.y}}function I(t,e){document.getElementById(`${t}cPointX`).value=e.point.x.toString(),document.getElementById(`${t}cPointY`).value=e.point.y.toString(),document.getElementById(`${t}cPointAngle`).value=e.angle.toString()}function b(t,e,n){document.getElementById(`${t}X`).value=e.x.toString(),document.getElementById(`${t}Y`).value=e.y.toString(),n&&(document.getElementById(`${t}Width`).value=n.width.toString(),document.getElementById(`${t}Height`).value=n.height.toString())}function G(t){b("rect1",t.rectList[0].rectangle.rect.position,t.rectList[0].rectangle.rect.size),I("rect1",t.rectList[0].rectangle.cPoint),b("rect2",t.rectList[1].rectangle.rect.position,t.rectList[1].rectangle.rect.size),I("rect2",t.rectList[1].rectangle.cPoint)}function B(t){return{position:{x:parseFloat(document.getElementById(`${t}X`).value),y:parseFloat(document.getElementById(`${t}Y`).value)},size:{width:parseFloat(document.getElementById(`${t}Width`).value),height:parseFloat(document.getElementById(`${t}Height`).value)}}}function M(t){return{point:{x:parseFloat(document.getElementById(`${t}cPointX`).value),y:parseFloat(document.getElementById(`${t}cPointY`).value)},angle:parseFloat(document.getElementById(`${t}cPointAngle`).value)}}function K(t,e){const n=B(t);if(n.position.x>0&&n.position.y>0&&n.size.height>0&&n.size.width>0)switch(e){case"right":return{point:{x:n.position.x+.5*n.size.width,y:n.position.y},angle:0};case"left":return{point:{x:n.position.x-.5*n.size.width,y:n.position.y},angle:180};case"up":return{point:{x:n.position.x,y:n.position.y+.5*n.size.height},angle:90};default:return{point:{x:n.position.x,y:n.position.y-.5*n.size.height},angle:270}}throw new Error("Ошибка: все параметры прямоугольника должны быть заданы положительными числами")}function J(t,e){t&&([e.rectList[0].rectangle,e.rectList[1].rectangle].forEach(n=>{t.fillRect(n.rect.position.x-.5*n.rect.size.width,n.rect.position.y-.5*n.rect.size.height,n.rect.size.width,n.rect.size.height),t.strokeStyle="black",t.lineWidth=1,t.strokeRect(n.rect.position.x-.5*n.rect.size.width,n.rect.position.y-.5*n.rect.size.height,n.rect.size.width,n.rect.size.height)}),t.strokeStyle="black",t.lineWidth=1,t.beginPath(),t.moveTo(e.path[0].x,e.path[0].y),e.path.forEach((n,o)=>{o&&t.lineTo(n.x,n.y)}),t.stroke())}function Q(t,e){t.strokeStyle="blue",t.lineWidth=2,t.strokeRect(e.position.x-.5*e.size.width,e.position.y-.5*e.size.height,e.size.width,e.size.height)}var u=(t=>(t[t.x=0]="x",t[t.y=1]="y",t))(u||{});function s(t){return t===0?"x":"y"}function V(t,e){return[t.position[s(e)]-.5*t.size[e?"height":"width"],t.position[s(e)]+.5*t.size[e?"height":"width"]]}function N(t,e){t=t.sort(n=>n);for(let n of e)if(n>t[0]&&n<t[1])return!1;return!0}function Z(t,e){return e=e.sort(n=>n),!!(t.every(n=>n<=e[0])||t.every(n=>n>=e[1]))}const D=20,tt=10,l={rectGap:D,rectLineGap:tt};function d(t,e,n){const o=e[0].x===e[1].x?u.x:u.y;for(let i of n){const r=[i.cornerPoints[0].y-t,i.cornerPoints[2].y+t],c=[i.cornerPoints[0].x-t,i.cornerPoints[2].x+t];if(!N(o?r:c,[e[0][s(o)]])&&!Z([e[0][s(1-o)],e[1][s(1-o)]],1-o?r:c))return!1}return!0}function et(t,e){return!(!S(t.cornerPoints).every(n=>d(l.rectGap,n,[e]))||!S(e.cornerPoints).every(n=>d(l.rectGap,n,[t])))}function S(t){return t.map((e,n)=>[e,n+1<t.length-1?t[n+1]:t[0]])}class m{constructor(e,n){f(this,"rect");f(this,"cPoint");f(this,"_sideX");f(this,"_sideY");this.rect=e,this.cPoint=n,this._sideX=this.sidePoints(u.x),this._sideY=this.sidePoints(u.y);const o=this.getSide();this.validateConnectionPoint(o),this.validateAngle(o)}getSide(){const e=[this.sideX,this.sideY];for(let n=0;n<2;n++)if(e[n].includes(this.cPoint.point[s(n)]))return n;throw new Error("Ошибка: Точка соединения должна находиться на грани прямоугольника.")}validateConnectionPoint(e){if(N(1-e?this.sideY:this.sideX,[this.cPoint.point[s(1-e)]]))throw new Error("Ошибка: Точка соединения должна находиться на грани прямоугольника.")}sidePoints(e){const n=V(this.rect,e);switch(e){case u.x:this._sideX=n;break;case u.y:this._sideY=n;break;default:throw new Error("Ошибка: Не удалось определить грань прямоугольника")}return n}validateAngle(e){switch(e){case u.x:if(this.cPoint.point[s(e)]===Math.max(...this._sideX)&&this.cPoint.angle===0||this.cPoint.point[s(e)]===Math.min(...this._sideX)&&this.cPoint.angle===180)return;break;case u.y:if(this.cPoint.point[s(e)]===Math.max(...this._sideY)&&this.cPoint.angle===90||this.cPoint.point[s(e)]===Math.min(...this._sideY)&&this.cPoint.angle===270)return;break;default:throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}get cornerPoints(){return[{x:this.sideX[0],y:this.sideY[0]},{x:this.sideX[0],y:this.sideY[1]},{x:this.sideX[1],y:this.sideY[1]},{x:this.sideX[1],y:this.sideY[0]}]}get sideX(){return this._sideX??this.sidePoints(u.x)}get sideY(){return this._sideY??this.sidePoints(u.y)}}function nt(t,e,n){for(let o of[{...t,x:e.x},{...t,y:e.y}])if(d(l.rectLineGap,[t,o],n)&&d(l.rectLineGap,[o,e],n))return{result:!0,point:o};return{result:!1}}const it=(t,e,n,o)=>{const i=new m(t,n),r=new m(e,o),c=[i.cPoint.point,$(i)],y=$(r);let P=!1;for(let Y=0;Y<10;Y++){const v=nt(c[c.length-1],y,[i,r]);if(v.result&&v.point){c.push(v.point),P=!0;break}try{const C=ot(c,y,[i,r]);C&&c.push(C)}catch{return[]}}return P?[...c,y,r.cPoint.point]:[]};function $(t){switch(t.cPoint.angle){case 0:return{...t.cPoint.point,x:t.cornerPoints[2].x+l.rectLineGap};case 180:return{...t.cPoint.point,x:t.cornerPoints[0].x-l.rectLineGap};case 90:return{...t.cPoint.point,y:t.cornerPoints[2].y+l.rectLineGap};case 270:return{...t.cPoint.point,y:t.cornerPoints[0].y-l.rectLineGap};default:throw new Error("Ошибка: Для одного из прямоугольников задан неверный угол. Убедитесь, что угол точки соединения направлен наружу от прямоугольника под углом 0, 90, 180 или 270 градусов. ")}}function ot(t,e,n){const o=t[t.length-1].x===t[t.length-2].x?u.x:u.y,i=t[t.length-1];let r;if((i[s(1-o)]-t[t.length-2][s(1-o)])*(e[s(1-o)]-i[s(1-o)])>0&&(r=c(),r.result&&r.point&&d(l.rectLineGap,[i,r.point],n))||i[s(o)]<e[s(o)]&&(r=A(i,1-o,n),r.result&&r.point&&d(l.rectLineGap,[i,r.point],n))||(r=F(i,1-o,n),r.result&&r.point&&d(l.rectLineGap,[i,r.point],n)))return r.point;if(r=c(),r.result&&r.point&&d(l.rectLineGap,[i,r.point],n))return r.point;throw new Error("Не удалось получить путь между точками");function c(){return i[s(1-o)]-t[t.length-2][s(1-o)]>0?A(i,o,n):F(i,o,n)}}function A(t,e,n){const o=n.map(i=>[i.cornerPoints[0][s(1-e)]-l.rectLineGap,i.cornerPoints[2][s(1-e)]+l.rectLineGap]).reduce((i,r)=>i.concat(r),[]).filter(i=>i>t[s(1-e)]);return o.length===0?{result:!1}:{result:!0,point:{x:e?Math.min(...o):t.x,y:e?t.y:Math.min(...o)}}}function F(t,e,n){const o=n.map(i=>[i.cornerPoints[0][s(1-e)]-l.rectLineGap,i.cornerPoints[2][s(1-e)]+l.rectLineGap]).reduce((i,r)=>r.concat(i),[]).filter(i=>i<t[s(1-e)]);return o.length===0?{result:!1}:{result:!0,point:{x:e?Math.max(...o):t.x,y:e?t.y:Math.max(...o)}}}class O{constructor(e,n,o,i){f(this,"rectList");f(this,"path");this.rectList=[new m(e,o),new m(n,i)].map((r,c)=>({id:c+1,rectangle:r,focused:!1})),this.path=[],this.resetPath()}resetPath(){this.path=it(this.rectList[0].rectangle.rect,this.rectList[1].rectangle.rect,this.rectList[0].rectangle.cPoint,this.rectList[1].rectangle.cPoint)}changeRectangle(e,n,o){return this.rectList[e-1].rectangle=new m(o??this.rectList[e-1].rectangle.rect,n??this.rectList[e-1].rectangle.cPoint),this.resetPath(),this}get notIntersectionRect(){return et(this.rectList[0].rectangle,this.rectList[1].rectangle)}}const E={rect1:{position:{x:150,y:200},size:{width:100,height:100}},rect2:{position:{x:350,y:300},size:{width:100,height:200}},cPoint1:{point:{x:100,y:200},angle:180},cPoint2:{point:{x:300,y:300},angle:180}},rt=new O(E.rect1,E.rect2,E.cPoint1,E.cPoint2);function st(t,e){const n={x:["left","right"].includes(e)?e==="left"?0-l.rectGap:l.rectGap:0,y:["up","down"].includes(e)?e==="down"?0-l.rectGap:l.rectGap:0};return W(t,n)}function W(t,e){return{newCPoint:{...t.cPoint,point:k(t.cPoint.point,e)},newRectPosition:{...t.rect,position:k(t.rect.position,e)}}}const _={ArrowRight:"right",ArrowLeft:"left",ArrowUp:"down",ArrowDown:"up"};function T(t,e){for(const n of e.rectList)if(!d(0,[t,t],[n.rectangle]))return n.id;return null}function H(t){const n=t.target.getBoundingClientRect();return{x:t.clientX-n.left,y:t.clientY-n.top}}const x=document.getElementById("errorMessage"),g=document.getElementById("canvas"),ct=document.getElementsByClassName("js-cpoint-coordinator");let a=rt;G(a);let h=null,w="";const R=(t,e)=>{var n;return(n=e.rectList.find(o=>o.id===t))==null?void 0:n.rectangle},p=g.getContext("2d"),L=()=>{if(p&&(p.clearRect(0,0,p.canvas.width,p.canvas.height),p.fillStyle="rgba(168, 210, 255)",J(p,a),h!==null)){const t=R(h,a);t&&Q(p,t.rect)}};L();document.getElementById("redrawButton").addEventListener("click",function(t){t.preventDefault(),U()});const lt=()=>{const t=e=>{g.style.cursor=T(H(e),a)?"grab":"default"};g.addEventListener("mousemove",t)};lt();const at=()=>{const t=n=>{if(!h)return;const o=R(h,a);if(!o)return;const i=n.pageX,r=n.pageY,c=y=>{X();const P=W(o,{x:y.pageX-i,y:y.pageY-r});h&&a.changeRectangle(h,P.newCPoint,P.newRectPosition),L(),G(a),z()};g.addEventListener("mousemove",c),g.addEventListener("mouseup",()=>g.removeEventListener("mousemove",c))},e=n=>{h=T(H(n),a)??null,L(),h&&g.addEventListener("mousedown",t)};g.addEventListener("mousedown",e)};at();window.addEventListener("keydown",function(t){e(t);function e(n){if(n.key in _){if(!h)return;const o=R(h,a);if(o){X();const i=st(o,_[n.key]);a.changeRectangle(h,i.newCPoint,i.newRectPosition),L(),G(a),z()}}}});Array.prototype.forEach.call(ct,t=>{t.addEventListener("click",function(e){e.target instanceof HTMLButtonElement&&e.target.dataset.action&&e.target.dataset.rect&&(I(e.target.dataset.rect,K(e.target.dataset.rect,e.target.dataset.action)),U())})});function U(){X();try{a=new O(B("rect1"),B("rect2"),M("rect1"),M("rect2")),L()}catch(t){w="Произошла ошибка. К сожалению, мы не смогли создать изображение по указанным параметрам. Пожалуйста, проверьте введенные данные и попробуйте снова.",t instanceof Error&&(w=t.message)}finally{z()}}function z(){w?x.textContent=w:a.path.length===0?x.textContent="Произошла ошибка. К сожалению, мы не смогли создать изображение по указанным параметрам. Пожалуйста, проверьте введенные данные и попробуйте снова.":a.notIntersectionRect?x.textContent="":x.textContent=`Ошибка: Прямоугольники расположены слишком близко друг к другу. Между их гранями должно быть минимальное расстояние в ${l.rectGap} пикселей. Пожалуйста, отредактируйте положение прямоугольников.`}function X(){w=""}
